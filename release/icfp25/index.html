<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mechanizations of Type Theories</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="styling.css" />
  <script type="text/javascript" src="style.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script>
   $(function () {
       $("pre>code").parents("pre").each(function(_) {
           var pre = this;
           for (c of pre.children) {
               c.classList.add(pre.className);
           }
       })
   })

   $(function() {
       var h1elem = $("h1")[0];
       h1elem.classList.add("project_title");
       var header = $(`<div id="header_wrap" class="outer">
          <header class="inner">
            
              <a id="forkme_banner" href="https://github.com/HuStmpHrrr/mech-type-theories">Fork on GitHub</a>
            ${h1elem.outerHTML}
          </header>
      </div>`);
       var body = h1elem.parentNode;
       h1elem.remove();
       var sec = document.createElement("section");
       sec.classList.add("inner");
       sec.innerHTML = body.innerHTML;
       body.innerHTML = '';
       body.appendChild(header[0]);
       body.appendChild(sec);
   })
  </script>
  <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h1 id="normalization-by-evaluation-for-non-cumulativity">Normalization
by Evaluation for Non-cumulativity</h1>
<p>This is an online artifact of our ICFP‚Äô25 paper of the same name. The
same artifact is also available on <a
href="https://zenodo.org/records/15686111">Zenodo</a>. Readers of this
artifact are encouraged to experiment with our artifact.</p>
<p>Normalization by evaluation (NbE) based on an untyped domain model is
a convenient and powerful way to normalize terms to their ùõΩùúÇ normal
forms. It enables a concise technical setup and simplicity for
mechanization. Nevertheless, to date, untyped NbE has only been studied
for cumulative universe hierarchies, and its correctness proof
critically relies on the cumulativity of the system. Therefore we are
faced with the question: whether untyped NbE applies to a non-cumulative
universe hierarchy? As such a universe hierarchy is also widely used by
proof assistants like Agda and Lean, this question is also of practical
significance.</p>
<p>Our work answers this question positively. One important property
derived from non-cumulativity is <a
href="NonCumulative.Ascribed.Consequences.html#7365">uniqueness</a>:
every term has a unique type. In light of the uniqueness property, we
work with <a href="NonCumulative.Ascribed.Statics.Full.html#836">a
Martin-L√∂f type theory with explicit universe levels</a> ascribed in the
syntactic judgments. On the semantic side, universe levels are also
explicitly managed, which leads to more complexity than the semantics
with a cumulative universe hierarchy. We prove that the NbE algorithm is
<a href="NonCumulative.Ascribed.Soundness.html">sound</a> and <a
href="NonCumulative.Ascribed.Completeness.html">complete</a>, and
confirm that NbE does work with non-cumulativity. Moreover, to capture
common practice more faithfully, we also show that the explicit
annotations of universe levels, though technically useful, are logically
redundant: NbE remains applicable without these annotations. As such, we
provide a mechanized foundation with NbE for non-cumulativity.</p>
<p>Please read <a href="README.html">README</a> for our
mechanization.</p>
<p>This library current works with Agda 2.7.0.1 and agda-stdlib
2.1.1.</p>
<p>This work is a continuation of a larger effort of <a
href="/mech-type-theories">mechanizing type theory in Agda</a>.</p>
<h2 id="installing-agda">Installing Agda</h2>
<p>It is recommended to build Agda from source. To do so, one would need
to install <code>stack</code>. This can be done via</p>
<pre class="bash"><code>curl -sSL https://get.haskellstack.org/ | sh</code></pre>
<p>Then the following script will use <code>stack</code> to install Agda
in <code>~/.local/bin/</code>.</p>
<pre class="bash"><code>git clone https://github.com/agda/agda
cd agda
git checkout a6fc20c # the commit id of 2.7.0.1
cp stack-8.8.4.yaml stack.yaml # choose your favourite Haskell version
stack install # it is going to take a while
cp ~/.local/bin/agda ~/.local/bin/agda-2.7.0.1
cp ~/.local/bin/agda-mode ~/.local/bin/agda-mode-2.7.0.1</code></pre>
<p>If Agda does not run, please check to make sure it is in your
PATH.</p>
<h2 id="foundation-and-assumptions">Foundation and Assumptions</h2>
<p>This library is implemented in safe Agda without K as much as
possible. For dependent type theories, however, it is necessary to
include the extension of induction-recursion. Functional extensionality
is sometimes used for dependent type theories as well. These extensions
are completely standard, as done in many other works.</p>
</body>
</html>
